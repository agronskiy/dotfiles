#!/usr/bin/env bash

set -eo pipefail

YASLI_DIR="$(dirname "$0")"
source $YASLI_DIR/logging.inc.sh
source $YASLI_DIR/install-utils.inc.sh

[ -z $DOTFILES ] && DOTFILES=$HOME/.dotfiles
[ -d $DOTFILES ] || log_fail "Requested dotfiles directory not found: $DOTFILES"

cd $DOTFILES

INDENT_NUM=2

if [ "$EUID" -ne 0 ]; then
  SUDO_CMD=sudo
else
  SUDO_CMD=
fi

# Priority install: everything that normal install needs.
failed_installers=()
install_order=( "yasli.pre" "yasli" "yasli.post" )
for order in "${install_order[@]}"
do
    while read installer ; do
        [ -z ${installer} ] && continue

        # Don't install `*.linux.install.sh` on non-linux
        if [[ "${installer}" == *linux.${order}.sh ]] && [ "$(uname -s)" != "Linux" ]; then
            log_success "Skipped linux-specific stuff in ${installer}"
            continue
        fi

        # Don't install `*.macos.install.sh` on nion-mac
        if [[ "${installer}" == *macos.${order}.sh ]] && [ "$(uname -s)" != "Darwin" ]; then
            log_success "Skipped macos-specific stuff in ${installer}"
            continue
        fi

        # Run as subshell to avoid polluting the environment, still keeping all functions
        # accessible to the subshell.
        (
            source "${installer}"
        ) || failed_installers+=( "${installer}" )

    # The reasn for here string is modifying the `failed_installers` - we need while to be run
    # not as a subshell
    done <<< "$(find "$DOTFILES" -type f -name "*${order}.sh")"
done

if [ ! ${#failed_installers[@]} -eq 0 ]; then
    log_fail "Some installers failed: ${failed_installers[@]}"
fi
